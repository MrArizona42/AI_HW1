# **Домашнее задание №1 (pro)**

Проект посвящен построению ML-сервиса по предсказанию цены автомобилей.

## О датасете

* Датасет содержал тренировочную и тестовую выборки размером
```
Train data shape: (6999, 13)
Test data shape:  (1000, 13)
```

Информация о колонках:
```
 0   name           6999 non-null   object 
 1   year           6999 non-null   int64  
 2   selling_price  6999 non-null   int64  
 3   km_driven      6999 non-null   int64  
 4   fuel           6999 non-null   object 
 5   seller_type    6999 non-null   object 
 6   transmission   6999 non-null   object 
 7   owner          6999 non-null   object 
 8   mileage        6797 non-null   object 
 9   engine         6797 non-null   object 
 10  max_power      6803 non-null   object 
 11  torque         6796 non-null   object 
 12  seats          6797 non-null   float64
```

## Предварительный анализ и предобработка

* Тренировочные данные содержали 14% дубликатов
* Пропуски присутствуют в колонках: `['mileage', 'engine', 'max_power', 'torque', 'seats']`

**Первичные инсайты на основе дашборда ydata-profiling:**

* Самая сильная отрицательная корреляция у переменной km_driven: -0.358
* Самая сильная положительная корреляция у переменной year: 0.714
* Остальные переменные также имеют корреляции 0.1 - 0.3 - 0.5, что позволяет предположить, что машинное обучение должно хорошо справиться с задачей предсказания цены автомобиля.
* Также есть сильная отрицательная корреляция между колонками km_driven и year
* Судя по WordCloud, в датасете данные с индийского авторынка. Самые популярные слова: maruti, mahindra
* Переменная year скошена вправо. Минимальное значение - 1983 год, 5% перцентиль - 2006 год. Максимальное значение - 2020 год.
* Целевая переменная price скошена влево. 5% перцентиль: 110000, 95% перцентиль: 1925000. Максимальное значение: 10000000.
* Лучше всего представлены типы двигателей: Diesel, Petrol, типов CNG и LPG всего 1.2%
* Из колонок mileage, engine, max_power, torque можно вытащить численные данные


Также было выяснено, что тренировочная выборка в достаточной степени похожа на тестовую: разница в средних и медианах у числовых перменных не превышает 3.4%

**Предобработка и начало feature engineering**

* Удалены дубликаты
* Заполнены пропуски числовых переменных медианами
* Получены новые числовые фичи на основе колонок `['mileage', 'engine', 'max_power', 'torque']`
* Получены колонки 'Brand' и 'Model' из колонки 'name'. Но в колонке еще остались другие неразмеченные данные.

## EDA

* По диаграммам рассеяния видно, что связь переменных с целевой переменной прослеживается. Особенно можно выделить сильную корреляцию с целевой переменной фичей 'max_torque' и 'max_power'
* Также можно проследить корреляции между остальными признаками. Например те же 'max_torque', 'max_power' и 'engine' (displacement) сильно коррелируют между собой.
* Распределения train и test похожи. Некоторые диаграммы отображены в другом масштабе, т.к. в тренировочных данных присутвуют сильно выбивающиеся значения, которых нет (меньше) в тестовых данных. Например, единичные выбросы в train в 'min_torque_rpm' и 'max_torque_rpm' сдвигают графики с основной частью к краю, чего не наблюдается в тестовых данных

Корреляции Пирсона
* Наименее скоррелированные 2 признака: 'engine' и 'year'. Также очень низкая корреляция между: 'max_power' - 'km_driven', 'min_torque_rpm' - 'mileage', 'max_torque_rpm' - 'max_power'
* Наиболее сильная положительная корреляция у набора признаков: 'max_power' - 'max_torque' - 'engine' - 'price'
* Между 'year' и 'km_driven' коэффициент корреляции равен -0.37, что соответствует средне-слабой отрицательной взаимосвязи.

Корреляции Phik
* При построении матрицы корреляций phik мы сразу видим warning, что поле name имеет много уникальных значений. Поэтому и коффицииенты $\phi$ для поля name почти все около 1.
* Для поля selling_price теперь можно посмотреть корреляции с категориальными переменными. Так, высокая корреляция у поля owner: 0.56.
* При этом например для поля km_driven корреляции ниже, чем были в корреляциями Пирсона.
* Еще из интересного - поле fuel очень хорошо объясняет min_torque_rpm - минимальные обороты максимального крутящего момента (что логично с точки зрения конструкции)
* Для числовых переменных картина похожая с корреляциями Пирсона (учитывая только что $\phi$ имеет диапазон от 0 до 1)


## Модель на числовых признаках

* Целевая метрика выбрана $R^2$
* Выбранный scaler: StandardScaler
* Бейзлайн на Lasso Линейной Регрессии на числовых фичах: best score $R^2 = 0.58$ на кросс-валидации. При этом $\alpha = 10000$, что соответствует занулению коэффициентов у фичей `['mileage', 'engine']`
* Elastic Net не улучшает результат, параметры сводятся к тем же, что и у Lasso

## Модель на чилосвых и категориальных признаках

* Выбранный encoder для базовых категориальных фичей: OHE
* Результат на CV с Ridge Регрессией: $R^2 = 0.78$

## Feature engineering

Собрал всю предобработку в один пайплайн. Для удобства испытаний я разнес функции по разным файлам.
* `importer.py` - импортирует все необходимое
* `pipeliner.py` - содержит скрипты запуска пайплайнов с разными функциями предобработки
* `research_preprocessors.py` - кастомные предобработчики

Добавлены новые колонки:
* Удельная мощность - прибавка в целевой метрике на уровне тысячных (0.3%)
* Год в квадрате - прибавки практически нет
* Оставшиеся данные из колонки 'name' были предобработаны как текстовое поле методом TFIDF. Получили прибавку в $R^2$ на 2%.
* Среднее вместо медианы для заполнения пропусков. Разницы в целевой метрике нет.

## Бизнес метрики

Реализованы 2 бизнес метрики:

$$
\text{business metric 1} = \frac{1}{n} \sum_{i=1}^n \mathbb{I} \left( \frac{|y_{\text{true},i} - y_{\text{pred},i}|}{y_{\text{true},i}} > 0.1 \right)
$$

$$
\text{business metric 2} = \frac{1}{n} \sum_{i=1}^n 
\begin{cases} 
\text{coef} \cdot (y_{\text{pred},i} - y_{\text{true},i})^2, & \text{if } (y_{\text{pred},i} - y_{\text{true},i}) < 0 \\ 
(y_{\text{pred},i} - y_{\text{true},i})^2, & \text{otherwise}
\end{cases}
$$

## Сервис на Fast API

Реализован простейший сервис на Fast API с Pydantic проверков входящих данных, который имеет 3 эндпойнта:
* `GET /` - тестовая "домашняя" страница.
    * На вход требует 1 параметр: `test_key: str`
    * На выходе выдает тестовый `str`
* `POST /predict_item` - для предсказания цены одного наблюдения
    * На вход требует JSON с параметрами
        * name: str
        * year: int
        * selling_price: int
        * km_driven: int
        * fuel: str
        * seller_type: str
        * transmission: str
        * owner: str
        * mileage: str
        * engine: str
        * max_power: str
        * torque: str
        * seats: float
    * На выходе выдает `float` с ценой
* `POST /predict_items` - для предсказания цены нескольких наблюдений
    * На вход требует список JSON по примеру выше
    * На выходе выдает список с ценами
    